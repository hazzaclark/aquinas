// COPYRIGHT (C) HARRY CLARK 2025
// STANDALONE REFERENCE UTILITY FOR SIMULATING THE MOTOROLA 68851 MMU

// THIS FILE PERTAINS TOWARDS THE FUNCTIONALITY ENCOMPASSING MEMORY READ AND WRITES
// UTILISING INTRINSIC C++ FEATURES TO DYNAMICALLY HELP WITH MEMORY OPERATIONS

// MOREOVER, THIS IS ESSENTIALLY A C++ PORT OF LIB68K_MEM - WHICH IS BEING REPURPOSED
// FOR THE SOLE BENEFIT OF REPRODUCING THE SAME EFFICIENT READ AND WRITES AS PER THE 68K BUS
// ALBEIT WITH SLIGHT ALTERATIONS TO ACCOMMODATE FOR THE INTRINSIC'S OF THE MMU

// NESTED INCLUDES

#include <mmu_mem.hh>
#include <mmu_def.hh>
#include <util.hh>

// SYSTEM INCLUDES

#include <cstdio>

using namespace aquinas::mmu_mem_opts;
using namespace aquinas::mmu_mem;
using namespace aquinas::util;

// CONSTRUCT THE BASE OBJECT OF THE MEMORY MANAGER
// THE INITIALISATION WILL PRESUPPOSE WHICH FLAGS ARE ENABLED

MEMORY_MANAGER::MEMORY_MANAGER()
{
    ENABLED_FLAGS[static_cast<size_t>(MEMORY_OPT_FLAG::BASIC)] = true;
    ENABLED_FLAGS[static_cast<size_t>(MEMORY_OPT_FLAG::VERBOSE)] = true;
}

// DETERMINE WHAT PARAMETERS/VALUES THE CURRENT BUFFER CONTAINS
bool MEMORY_BUFFER::MEM_CONTAINS(U32 ADDRESS) const noexcept
{
    return ADDRESS >= BASE && ADDRESS <= END;
}

// RETURNS AN ITERATOR CLAUSE FROM THE FIRST ELEMENT IN A SPECIFIED RANGE
// IN THIS INSTANCE, WE WANT TO BE ABLE TO DETERMINE IF THERE IS A VALID
// BUFFER FOUND IN RELATION TO THE BASE AND END OF THE MAP

MEMORY_BUFFER* MEMORY_MANAGER::MEM_FIND(U32 ADDRESS)
{
    VERBOSE_TRACE("FOUND MEMORY: 0x%08X", ADDRESS);
    auto FOUND = std::find_if(BUFFERS.begin(), BUFFERS.end(), 
                                [ADDRESS](const auto& BUFFER)
                                {
                                    return BUFFER && BUFFER->MEM_CONTAINS(ADDRESS);
                                });

    // DETERMINE WHEN WE HAVE REACHED THE END OF A DESIGNATED BUFFER
    if(FOUND != BUFFERS.end())
    {
        // PRESUPPOSE THE CURRENT BUFFER THAT IS FOUND
        const auto& BUFFER = *FOUND;

        // CALCULATE THE BUFFER INDEX BASED ON THE SIZE AND WHAT IS FOUND
        size_t BUFFER_INDEX = std::distance(BUFFERS.begin(), FOUND);

        VERBOSE_TRACE("ACCESSED: 0x%08X [%s] IN BUFFER %u 0x%08X - 0x%08X\n", 
                        ADDRESS, 
                        BUFFER->MEM_WRITEABLE() ? "RW" : "RO",
                        BUFFER_INDEX,
                        BUFFER->MEM_BASE(),
                        BUFFER->MEM_END());

        return FOUND->get();
    }
    
    return nullptr;
}

// MAP THE CORRESPONDING MEMIORY IN RELATION TO THE PROVIDED PARAMETERS
// THIS WORKS ON THE BASIS OF ADDING THE FIRST PARAM TO THE END OF THE  VECTOR 

bool MEMORY_MANAGER::MAP_MEMORY(U32 BASE, U32 END, bool WRITEABLE)
{
    const U32 SIZE = (END - BASE) + 1;

    // HAVE WE REACHED THE END OF THE BUFFER?
    if(BUFFERS.size() >= MAX_BUFFERS)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BUFFER,
                    static_cast<MEMORY_SIZE>(SIZE),
                    "CANNOT MAP - TOO MANY BUFFERS");

        return false;
    }

    // HAS THE END REACHED THE MAX?
    if(END > MAX_ADDR_END)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BUS,
                    static_cast<MEMORY_SIZE>(SIZE),
                    "END ADDRESS EXCEEDS BUS LIMIT");
    }

    auto BUFFER = std::make_unique<MEMORY_BUFFER>(BASE, END, WRITEABLE);
    BUFFERS.push_back(std::move(BUFFER));

    return true;
}

// DEFINE A HELPER FUNCTION FOR BEING ABLE TO PLUG IN ANY RESPECTIVE
// ADDRESS AND SIZE BASED ON THE PRE-REQUISITE SIZING OF THE ENUM

// THESE MANAGER FUNCTIONS HELP WITH BEING ABLE TO MODUARLISE FUNCTIONALITY
// BETWEEN MANAGER AND BUFFER - SEPERATING BUS AND MMU SPECIFIC MEMORY FUNCTIONS

U32 MEMORY_MANAGER::MEMORY_READ(U32 ADDRESS, MEMORY_SIZE MEM_SIZE)
{
    VERBOSE_TRACE("READING ADDRESS FROM 0x%08X (SIZE = %d)\n", ADDRESS, FORMAT_SIZE(static_cast<size_t>(MEM_SIZE)));

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > MAX_ADDR_END)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::RESERVED, MEM_SIZE,
                "ATTEMPT TO READ FROM RESERVED ADDRESS RANGE");

        MEM_TRACE(MEMORY_OPTION::INVALID_READ, ADDRESS, MEM_SIZE, ~0U);
        return 0;
    }

    if(ADDRESS > MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BOUNDS, MEM_SIZE,
                "ATTEMPT TO READ FROM ADDRESS BEYOND ADDRESSABLE SPACE");

        MEM_TRACE(MEMORY_OPTION::INVALID_READ, ADDRESS, MEM_SIZE, ~0U);
        return 0;
    }

    // PRESUPPOSE THE ARBITARY SIZE OF THE BUFFER
    // USE THIS TO FIND THE CURRENT BUFFER AND IT'S PRE-REQUISTIES

    if(auto* BUFFER = MEM_FIND(ADDRESS))
    {
        // IF WE HAVE FOUND A RESULT, READ FROM THAT CURRENT BUFFER
        if(auto RESULT = BUFFER->MEM_READ(ADDRESS, MEM_SIZE))
        {
            MEM_TRACE(MEMORY_OPTION::READ, ADDRESS, MEM_SIZE, *RESULT);
            return *RESULT;
        }

        else
        {
            MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BOUNDS, MEM_SIZE,
                        "READ OUT OF BOUNDS, VIOLATION #", BUFFER->MEM_USAGE().VIOLATION);
            
            MEM_TRACE(MEMORY_OPTION::INVALID_READ, ADDRESS, MEM_SIZE, ~0U);
            return 0;
        }
    }

    MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::UNMAPPED, MEM_SIZE,
                "NO BUFFER FOUND FOR ADDRESS");
    MEM_TRACE(MEMORY_OPTION::INVALID_READ, ADDRESS, MEM_SIZE, ~0U);
    return 0;
}

void MEMORY_MANAGER::MEMORY_WRITE(U32 ADDRESS, U32 VALUE, MEMORY_SIZE MEM_SIZE)
{
    VERBOSE_TRACE("WRITING TO ADDRESS 0x%08X (SIZE = %d), VALUE = 0x%08X)\n", ADDRESS, FORMAT_SIZE(static_cast<size_t>(MEM_SIZE)), VALUE);

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > MAX_ADDR_END)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::RESERVED, MEM_SIZE,
                "ATTEMPT TO WRITE FROM RESERVED ADDRESS RANGE");

        MEM_TRACE(MEMORY_OPTION::INVALID_WRITE, ADDRESS, MEM_SIZE, VALUE);
        return;
    }

    if(ADDRESS > MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BOUNDS, MEM_SIZE,
                "ATTEMPT TO WRITE TO ADDRESS BEYOND ADDRESSABLE SPACE");

        MEM_TRACE(MEMORY_OPTION::INVALID_WRITE, ADDRESS, MEM_SIZE, VALUE);
        return;
    }

    // PRESUPPOSE THE ARBITARY SIZE OF THE BUFFER
    // USE THIS TO FIND THE CURRENT BUFFER AND IT'S PRE-REQUISTIES

    // IF WE HAVE FOUND A RESULT, READ FROM THAT CURRENT BUFFER

    auto* BUFFER = MEM_FIND(ADDRESS);
    if(!BUFFER)
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::UNMAPPED, MEM_SIZE,
                    "NO BUFFER FOUND FOR ADDRESS");

        MEM_TRACE(MEMORY_OPTION::INVALID_WRITE, ADDRESS, MEM_SIZE, VALUE);
        return;
    }

    // PRESUPPOSE AN ATTEMPT TO PERFORM THE WRITE OPERATION
    if(BUFFER->MEM_WRITE(ADDRESS, VALUE, MEM_SIZE))
    {
        MEM_TRACE(MEMORY_OPTION::WRITE, ADDRESS, MEM_SIZE, VALUE);
        return;
    } 

    // DISCERN WHETHER WE HAVE ENCOUNTERED A WRITE FAILURE OR A READONLY STATE
    if(!BUFFER->MEM_WRITEABLE())
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::READONLY, MEM_SIZE,
                 "WRITE ATTEMPT TO READONLY MEMORY, VIOLATION #", BUFFER->MEM_USAGE().VIOLATION);
    }

    else
    {
        MEM_ERROR(MEMORY_OPTION::ERROR, MEMORY_ERROR::BOUNDS, MEM_SIZE,
                 "WRITE OUT OF BOUNDS, VIOLATION #", BUFFER->MEM_USAGE().VIOLATION);
    }

    MEM_TRACE(MEMORY_OPTION::INVALID_WRITE, ADDRESS, MEM_SIZE, VALUE);
}

// SHOWS ALL OF THE MEMORY MAPS CURRRENTLY ALLOCATED AND DEFINE
// AS PER THE CONTENTS OF THEIR PRE-REQUISITES

// IT WILL LOOK TO DETERMINE THE SIZE OF HOW MANY ARE THERE
// THE INDEXXING OF THE BUFFERS IN QUESTION ALL TO DETERMINE THEIR CHARACTERISTIC

void MEMORY_MANAGER::SHOW_MEMORY_MAPS() const
{
    printf("\n%s MEMORY MAPS:\n", STOPPED ? "AFTER" : "BEFORE");
    printf("---------------------------------------------------------------\n");
    printf("START        END         SIZE    STATE  READS   WRITES  ACCESS\n");
    printf("---------------------------------------------------------------\n");
    
    for (unsigned INDEX = 0; INDEX < BUFFERS.size(); INDEX++)
    {
        const auto& BUFFER = BUFFERS[INDEX];
        if (BUFFER)
        {
            unsigned SIZE = BUFFER->MEM_END() - BUFFER->MEM_BASE() + 1;
            printf("0x%08X 0x%08X  %3ld%s     %2s  %6u  %6u      %s\n",
                    BUFFER->MEM_BASE(),
                    BUFFER->MEM_END(),
                    FORMAT_SIZE(SIZE), 
                    FORMAT_UNIT(SIZE).c_str(),
                    BUFFER->MEM_WRITEABLE() ? "RW" : "RO",
                    BUFFER->MEM_USAGE().READ_COUNT,
                    BUFFER->MEM_USAGE().WRITE_COUNT,
                    BUFFER->MEM_USAGE().ACCESSED ? "YES" : "NO");
        }
    }
    printf("---------------------------------------------------------------\n");
}

// THE FOLLOWING WILL LOOK TO MAKE A UNIQUE POINTER NOTATION BASED ON
// THE ARBITRARY TYPE CASTED SIZE OF THE MEMORY READ

// SIMILAR TO LIB68K_MEM, THIS WILL LOOK TO BE ABLE TO MANUALLY CAST
// THE REQUIRED TYPE FOR THR CURRENT MEMORY OPERATION

std::unique_ptr<U32> MEMORY_BUFFER::MEM_READ(U32 ADDRESS, MEMORY_SIZE MEM_SIZE)
{
    // READ RESULT BASED ON STATICALLY CAST SIZE
    U32 RESULT = 0;

    if (!MEM_CONTAINS(ADDRESS)) { return nullptr; }

    // OFFSET WILL ALWAYS BE BASED ON THE START (HELPS WITH BE READS)
    const U32 OFFSET = ADDRESS - BASE;
    const U32 BYTES = static_cast<U32>(MEM_SIZE) / 8;

    // BOUNDS CHECKING FOR CHECKING MEMORY VIOLATIONS
    // OF A DESIGNATED REGION
    if(OFFSET + BYTES > SIZE)
    {
        USAGE.VIOLATION++;
        return nullptr;
    }

    // FIRST WE READ AND DETERMINE THE READ STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
    // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
    // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL READS

    USAGE.READ_COUNT++;
    USAGE.LAST_READ = ADDRESS;
    USAGE.ACCESSED = true;

    // CREATE A GENERAL POINTER NOTATION FOR THE BUFFER
    // DISCERNS THE PROVIDED SIZE SUBSEQUENTLY
    const U8* BUFFER_PTR = BUFFER.get() + OFFSET;
    
    switch (MEM_SIZE)
    {
        case MEMORY_SIZE::SIZE_8:
            RESULT =    static_cast<U32>(BUFFER_PTR[0]);
            break;

        case MEMORY_SIZE::SIZE_16:
            RESULT =    static_cast<U32>(BUFFER_PTR[0]) << 8 |
                        static_cast<U32>(BUFFER_PTR[1]);
            break;

        case MEMORY_SIZE::SIZE_32:
            RESULT =    static_cast<U32>(BUFFER_PTR[0]) << 24 |
                        static_cast<U32>(BUFFER_PTR[1]) << 16 |
                        static_cast<U32>(BUFFER_PTR[2]) << 8 |
                        static_cast<U32>(BUFFER_PTR[3]);
            break;
    }

    return std::make_unique<U32>(RESULT);
}

// NOW WE DO THE SAME FOR THE WRITES
bool MEMORY_BUFFER::MEM_WRITE(U32 ADDRESS, U32 VALUE, MEMORY_SIZE MEM_SIZE)
{
    if (!MEM_CONTAINS(ADDRESS) || !WRITEABLE) { return false; }

    if(!WRITEABLE)
    {
        USAGE.VIOLATION++;
        return false;
    }
    
    const U32 OFFSET = ADDRESS - BASE;
    const U32 BYTES = static_cast<U32>(MEM_SIZE) / 8;

    // BOUNDS CHECKING FOR CHECKING MEMORY VIOLATIONS
    // OF A DESIGNATED REGION
    if(OFFSET + BYTES > SIZE)
    {
        USAGE.VIOLATION++;
        return false;
    }

    // FIRST WE READ AND DETERMINE THE WRITE STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
    // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
    // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL WRITES

    USAGE.WRITE_COUNT++;
    USAGE.LAST_WRITE = ADDRESS;
    USAGE.ACCESSED = true;

    // CREATE A GENERAL POINTER NOTATION FOR THE BUFFER
    // DISCERNS THE PROVIDED SIZE SUBSEQUENTLY
    U8* BUFFER_PTR = BUFFER.get() + OFFSET;
    
    switch (MEM_SIZE)
    {
        case MEMORY_SIZE::SIZE_8:
            BUFFER_PTR[0] = VALUE & 0xFF;
            break;

        case MEMORY_SIZE::SIZE_16:
            BUFFER_PTR[0] = (VALUE >> 8) & 0xFF;
            BUFFER_PTR[1] = VALUE & 0xFF;
            break;

        case MEMORY_SIZE::SIZE_32:
            BUFFER_PTR[0] = (VALUE >> 24) & 0xFF;
            BUFFER_PTR[1] = (VALUE >> 16) & 0xFF;
            BUFFER_PTR[2] = (VALUE >> 8) & 0xFF;
            BUFFER_PTR[3] = VALUE & 0xFF;
            break;
    }
        
    return true;
}

bool MEMORY_MANAGER::IS_TRACE_ENABLED(MEMORY_OPT_FLAG FLAG) const noexcept { return ENABLED_FLAGS[static_cast<size_t>(FLAG)]; }
void MEMORY_MANAGER::ENABLE_TRACE_FLAGS(MEMORY_OPT_FLAG FLAG) noexcept { ENABLED_FLAGS[static_cast<size_t>(FLAG)] = true; }
void MEMORY_MANAGER::DISABLE_TRACE_FLAGS(MEMORY_OPT_FLAG FLAG) noexcept { ENABLED_FLAGS[static_cast<size_t>(FLAG)] = false; }

U8 MEMORY_MANAGER::MEM_READ_8(U32 ADDRESS) { return static_cast<U8>(MEMORY_READ(ADDRESS, MEMORY_SIZE::SIZE_8)); }
U16 MEMORY_MANAGER::MEM_READ_16(U32 ADDRESS) { return static_cast<U16>(MEMORY_READ(ADDRESS, MEMORY_SIZE::SIZE_16)); }
U32 MEMORY_MANAGER::MEM_READ_32(U32 ADDRESS) { return MEMORY_READ(ADDRESS, MEMORY_SIZE::SIZE_32); }

void MEMORY_MANAGER::MEM_WRITE_8(U32 ADDRESS, U8 VALUE) { MEMORY_WRITE(ADDRESS, VALUE, MEMORY_SIZE::SIZE_8); }
void MEMORY_MANAGER::MEM_WRITE_16(U32 ADDRESS, U16 VALUE) { MEMORY_WRITE(ADDRESS, VALUE, MEMORY_SIZE::SIZE_16); }
void MEMORY_MANAGER::MEM_WRITE_32(U32 ADDRESS, U32 VALUE) { MEMORY_WRITE(ADDRESS, VALUE, MEMORY_SIZE::SIZE_32); }

// COPYRIGHT (C) HARRY CLARK 2025
// STANDALONE REFERENCE UTILITY FOR SIMULATING THE MOTOROLA 68851 MMU

// THIS FILE PERTAINS TOWARDS THE FUNCTIONALITY ENCOMPASSING MEMORY READ AND WRITES
// UTILISING INTRINSIC C++ FEATURES TO DYNAMICALLY HELP WITH MEMORY OPERATIONS

// MOREOVER, THIS IS ESSENTIALLY A C++ PORT OF LIB68K_MEM - WHICH IS BEING REPURPOSED
// FOR THE SOLE BENEFIT OF REPRODUCING THE SAME EFFICIENT READ AND WRITES AS PER THE 68K BUS
// ALBEIT WITH SLIGHT ALTERATIONS TO ACCOMMODATE FOR THE INTRINSIC'S OF THE MMU

// NESTED INCLUDES

#include <mmu_mem.hh>
#include <mmu_def.hh>

using namespace aquinas::mmu_mem_opts;
using namespace aquinas::mmu_mem;

// CONSTRUCT THE BASE OBJECT OF THE MEMORY MANAGER
// THE INITIALISATION WILL PRESUPPOSE WHICH FALGS ARE ENABLED

MEMORY_MANAGER::MEMORY_MANAGER()
{
    ENABLED_FLAGS[static_cast<size_t>(MEMORY_OPT_FLAG::BASIC)] = true;
    ENABLED_FLAGS[static_cast<size_t>(MEMORY_OPT_FLAG::VERBOSE)] = true;
}

// RETURNS AN ITERATOR CLAUSE FROM THE FIRST ELEMENT IN A SPECIFIED RANGE
// IN THIS INSTANCE, WE WANT TO BE ABLE TO DETERMINE IF THERE IS A VALID
// BUFFER FOUND IN RELATION TO THE BASE AND END OF THE MAP

MEMORY_BUFFER* MEMORY_MANAGER::MEM_FIND(U32 ADDRESS)
{
    auto FOUND = std::find_if(BUFFERS.begin(), BUFFERS.end(), 
                                [ADDRESS](const auto& BUFFER)
                                {
                                    return BUFFER && BUFFER->MEM_CONTAINS(ADDRESS);
                                });
    
    return nullptr;
}

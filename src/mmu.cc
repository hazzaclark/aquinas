// COPYRIGHT (C) HARRY CLARK 2025
// STANDALONE REFERENCE UTILITY FOR SIMULATING THE MOTOROLA 68851 MMU

// THIS FILE PERTAINS TOWARDS THE MOUDLARISATION OF THE MMU

// NESTED INCLUDES

#include <mmu.hh>
#include <mmu_mem.hh>
#include <mmu_def.hh>

using namespace aquinas;

/////////////////////////////////////////////////////////////////
//                 MMU MAIN INITIALISATION
/////////////////////////////////////////////////////////////////

mmu::MMU_BASE::MMU_BASE()
    : CRP(0), SRP(0), TC(0), SR(0), TRANS(0), MEM(nullptr)
{
    TLB.clear();
}

// INITIALISE THE ATC BASED ON THE PRE-REQUISITIES ASSOCIATED
// THE FOLLOWING WILL LOOK TO DETERMINE:

// THE SIZE OF THE ATC LOOKUP TABLE
// CLEAR/FLUSH ANY TRAILING ENTRIES 
// DETERMINE THE STATISTICS BASED ON MODE

void mmu::MMU_BASE::ATC_INIT(void) noexcept
{
    ENTRIES.resize(MMU_ATC_ENTRIES);
    STATS = {0, 0, 0, 0, 0};

    printf("ATC INITIALIZED: %d ENTIRES\n", ATC_SIZE());
}

// INSERT AN ATC ENTRY BASED ON THE PRESUPPOSITION OF A
// LOGICAL AND PHYSICAL PAGE

bool mmu::MMU_BASE::INSERT_ATC_ENTRY(U32 LOG_ADDR, U32 PHYS_ADDR, U8 FUNC, U8 PERMS) noexcept
{
    U32 LOG_PAGE = LOG_ADDR & MMU_PAGE_MAX;
    U32 PHYS_PAGE = PHYS_ADDR & MMU_PAGE_MAX;

    // CHECK IF WE ALREADY HAVE AN EXISTING ENTRY
    unsigned EXISTING_INDEX = FIND_ATC_ENTRY(LOG_PAGE, FUNC);

    if(EXISTING_INDEX)
    {
        atc::ATC_ENTRY& ENTRY = ENTRIES[EXISTING_INDEX];
        ENTRY.PHYS_ADDR = PHYS_PAGE;
        ENTRY.PERM = PERMS;
        ENTRY.LAST_ACCESS++;
        ENTRY.USED = true;

        printf("ATC ENTRY UPDATED: [L]: 0x%08X [P]: 0x%08X [FC]: %d [PERM]: 0x%02X\n", 
               LOG_PAGE, PHYS_PAGE, FUNC, PERMS);

        return true;
    }

    // FIND RELEVANT INFORMATION WITHIN THE CACHE TO BE ABLE 
    // TO DETERMINE IF AN OLD ENTRY CAN BE EVICTED

    int ATC_VICTM_INDEX = MAKE_ATC_ENTRY();
    if(ATC_VICTM_INDEX < 0)
    {
        printf("ATC ERROR: NO AVAILABLE ENTRIES\n");
        return false;
    }

    // EVICT OLD ENTRIES IS VALID
    if(ENTRIES[ATC_VICTM_INDEX].IS_VALID)
    {
        STATS.EVICT++;
        printf("ATC EVICTED: L:0x%08X (ACCESSED %u TIMES)\n",
               ENTRIES[ATC_VICTM_INDEX].LOG_ADDR,
               ENTRIES[ATC_VICTM_INDEX].LAST_ACCESS);
    }

    // CREATE THE NEW ENTRY
    atc::ATC_ENTRY& NEW_ENTRY = ENTRIES[ATC_VICTM_INDEX];
    NEW_ENTRY.LOG_ADDR = LOG_PAGE;
    NEW_ENTRY.PHYS_ADDR = PHYS_PAGE;
    NEW_ENTRY.FUNC_CODE = FUNC;
    NEW_ENTRY.PERM = PERMS;
    NEW_ENTRY.IS_VALID = true;
    NEW_ENTRY.MODIFIED = false;
    NEW_ENTRY.USED = true;

    printf("ATC ENTRY INSERTED: L:0x%08X -> P:0x%08X FC:%d PERM:0x%02X INDEX:%d\n", 
           LOG_PAGE, PHYS_PAGE, FUNC, PERMS, ATC_VICTM_INDEX);

    return true;
}

// FIND AN ARBITRARY ATC ENTRY BASED ON A LOGICAL PAGE ADDRESS
// AND IT'S RESPECTIVE FUNCTION CODE

// THIS IS A BASIC IMPLEMENTATION OF A LINEAR SEARCH
// UNLESS NEEDED OTHERWISE, THIS WON'T REALLY NEED A WHOLE VERBOSE IMPLEMENTATION

int mmu::MMU_BASE::FIND_ATC_ENTRY(U32 LOG_PAGE, U8 FUNC) const noexcept
{
    const atc::ATC_ENTRY* const ENTRY = ENTRIES.data();
    const U32 SIZE = ATC_SIZE();
    
    // ITERATE THROUGH EACH ALLOCATABLE SPACE TO DETERMINE
    // THE SIZE FOR ENTRY
    
    for(std::size_t INDEX = 0; INDEX < SIZE; ++INDEX)
    {
        const atc::ATC_ENTRY& ENTRY_INDEX = ENTRY[INDEX];

        // SANITY CHECK FOR LIKLEIHOOD OF ENTRY
        if(!ENTRY->IS_VALID) continue;

        if(ENTRY_INDEX.LOG_ADDR == LOG_PAGE &&
            ENTRY_INDEX.FUNC_CODE == FUNC)
        {
            return static_cast<int>(INDEX);
        }
    }

    return -1;
}

// THE FOLLOWING WILL ITERATE THROUGH THE RESPECTIVE SIZE 
// OF AN ATC LOOKUP INDEX, TO DETERMINE ANY INVALID ENTRIES

// WHAT MAKES THIS DIFFERENT THAN THE ABOVE FUNCTION IS THAT
// WE WANT TO BE ABLE TO MODULARISE THE MEANS BY WHICH WE CHECK
// FOR INVALID VICTIMS WITHIN THE ENTRY TABLE

int mmu::MMU_BASE::MAKE_ATC_ENTRY(void) const noexcept
{
    // LOOK FOR INVALID ENTRIES
    for(U32 INDEX = 0; INDEX < ATC_SIZE(); INDEX++)
    {
        if(!ENTRIES[INDEX].IS_VALID) { return INDEX; }
    }

    // NOW WE CAN BEGIN TO LOOK FOR A RESPECTIVE LRU INDEX
    // WITHIN THE ENTRY TABLE - HELPS SIGNIFICANTLY WHEN
    // DETERMINING THE LEAST USED INDEX WITHIN A STRUCTURE

    // THIS IS DETERMINED BY AN LRU INDEX COUNTER
    // AND THE ACTUAL AMOUNT OF LEAST USED ELEMENTS
    // COMPARING AGAINST THE COUNTER

    int LRU_INDEX = 0;
    U64 LAST_CHECKED = ENTRIES[0].LAST_ACCESS;

    for(U32 LRU = 1; LRU < ATC_SIZE(); LRU++)
    {
        if(ENTRIES[LRU].LAST_ACCESS < LAST_CHECKED)
        {
            LAST_CHECKED = ENTRIES[LRU].LAST_ACCESS;
            LRU_INDEX = LRU;
        }
    }

    return LRU_INDEX;
}

// THESE PAGES WILL LOOK TO DETERMINE IF AN EXISTING INDEX ALREADY
// RESIDES WITHIN THAT CHUNK

// SIMPLE INSERTION FOR THE PAGING TLB 
// ALL OF THIS JUST PRESUPPOSES A RAW ARRAY WHICH ACCESSES THE 
// LOGICAL PAGE AGAINST THE PHYSICAL PAGE

void mmu::MMU_BASE::INSERT_TLB(U32 LOG_ADDRESS, U32 PHYS_ADDRESS) noexcept
{
    U32 LOG_PAGE = LOG_ADDRESS & MMU_PAGE_MAX;
    U32 PHYS_PAGE = PHYS_ADDRESS & MMU_PAGE_MAX;

    // ADD TO THE TLB BUFFER
    TLB[LOG_PAGE] = PHYS_PAGE;
    printf("TLB ENTRY INSERTED: 0x%08X -> 0x%08X\n", LOG_PAGE, PHYS_PAGE);
}

// LOOKUP THE TABLE BASED ON A LOGICAL AND PHYSCIAL ADDRESS
// THIS IS TO DETERMINE THE PAGING BETWEEN MEMORY CHUNKS
// TO DETERMINE WHAT IS A LOGICAL OR PHYSICAL ADDRESS

bool mmu::MMU_BASE::LOOKUP_TLB(U32 LOG_ADDRESS, U32& PHYS_ADDRESS) noexcept
{
    U32 PAGE = LOG_ADDRESS & MMU_PAGE_MAX;
    auto INDEX = TLB.find(PAGE);

    // ASSUME WE AREN'T AT THE END
    // PROCEED TO INDEX AGAINST ALL SECONDARY ELEMENTS IN RELATION
    // TO THE OFFSET
    if(INDEX != TLB.end())
    {
        PHYS_ADDRESS = INDEX->second | (LOG_ADDRESS & MMU_PAGE_OFF);
        return true;
    }

    return false;
}

// SIMILAR EXECUTION LOOP AKIN TO THE LIKENESS OF LIB68K
// UTILISES A FUNCTION POINTER IN ORDER TO DYNAMICALLY DETERMINE 
// OPCODE DECLARATIVES, PC ADVANCEMENTS, ETC

void mmu::opcode::MMU_EXEC(mmu_mem::MEMORY_MANAGER* MEM)
{
    // 31/08/25
    // A LOT OF THESE ARE HERE SIMPLY BECAUSE THAT UNLIKE LIB68K
    // WE ARENT REALLY TOO CONCERNED WITH HAVING AN OVERARCHING
    // CYCLE COUNT - AS WE ARE EMULATING THE CPU CYCLE ACCURATELY

    std::unique_ptr<MMU_BASE> INST = std::make_unique<MMU_BASE>(MEM);
    int OPCODE_CYCLES = 0;
    int CYCLES_USED = 0;

    while(!INST->MEM->IS_STOPPED())
    {
        // READ THE CURRENT INSTRUCTION INTO A MOCK IR
        // DISCERN HOW MANY CYCLES IT TAKES
        INST->IR = INST->MEM->MEM_READ_16(INST->PC);
            
        OPCODE_CYCLES = MMU_CYCLE_RANGE[INST->IR];

        printf("[PC -> %04X]  [IR -> %04X]  ", 
               INST->PC, INST->IR);

        // PASS THE INDEXXED OPCODE INTO THE FUNCTION POINTER
        MMU_OPCODE_HANDLER[INST->IR](INST.get());

        INST->PC += 2;
        CYCLES_USED += OPCODE_CYCLES;
    }
    
    printf("\nTOTAL CYCLES USED: %d\n", CYCLES_USED);
}
